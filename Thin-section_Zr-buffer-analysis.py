# -*- coding: utf-8 -*-
"""
NOTE: This code uses GIS related packages - an older version of Python may be 
      required. This script was created with Python 3.7.

This script quantifies the closer mineral content of measured zircon grains within
thin-sections by overlaying the point grid data generated from a TIMA-phasemap-image 
(see 'ImageRGB-Mineral-correlation.txt') with the buffer polygons of measured 
zircon grains generated from ArcGis. 

WORKFLOW:
    1. Load the point grid data and the buffer polygons
    2. Change the point data into "spatial ArcGis points"
    3. Iterate over the buffer polygons and count each "mineral-point" and 
       determine the minerals percentage within the buffer polygon
    4. Add the grain-ID and optional other information stored within the buffer
       polygon's geodatabase, e.g. concordia age of the zircon grain.
    5. Output Table: Mineral, mineral_amount_perc, grainID, ConcAge

USER INPUT:
    Point grid data - Location\filename.csv (line 44)
    Buffer polygons - Location\filename.gdb and layer name (line 48)
    Optional infos adding to the output table (line 88)
    Storage - Location\filename.csv (line 100)
    
Created:24/06/2020
Last modified: 07/09/2021
Author: Isabel Zutterkirch
"""

#------------------------------------------------------------------------------
## USED MODULS

import pandas as pd
import geopandas as gpd
from shapely import speedups
speedups.enabled

#------------------------------------------------------------------------------
## LOAD DATA of the thin-section

# data grid with mineral phase information stored in each point generated by
# the script 'ImageRGB-Mineral-correlation_Zr.py'
data_all_PhasePoints=pd.read_csv(r'C:\foldername\filename.csv',names=['Y','X','Mineral'])         
# geodatabase from ArcGis: buffers (any area, the user want to quantify its mineral
# phase content can be chosen, here we quantify the mineral content in the surrounding buffer area 
# of concordant zircon grains)
buffer= gpd.read_file(r'C:\foldername\filename.gdb', layer= 'buffer_concZr')

#------------------------------------------------------------------------------
## CHANGE DATA for processing

# change pandasDataFrame to GeoDataFrame, PONTS
data_all_PhasePoints=gpd.GeoDataFrame(data_all_PhasePoints, geometry=gpd.points_from_xy(data_all_PhasePoints.X,data_all_PhasePoints.Y))
# create spatial index for the points
data_all_PhasePoints_sindex= data_all_PhasePoints.sindex

#------------------------------------------------------------------------------
## DATA PROCESSING/CALCULATIONS

# create empty DataFrame 
Table_buffer= pd.DataFrame()
# iterate over the range of the buffers (here surrounding concordant zircon polygons)
for i in range(len(buffer)):
    # select buffer
    buffer_polygon= buffer['geometry'].iloc[i][0]
    # get the x y value of the points generating that buffer polygon 
    x_buffer,y_buffer= buffer_polygon.exterior.xy
    # get the bounding box of that polygon
    bbox= [min(x_buffer), min(y_buffer), max(x_buffer), max(y_buffer)]
    # get the indices of the PhasePoints that are likely to be inside the buffer polygon's bounding box
    point_candidate_idx= list(data_all_PhasePoints_sindex.intersection(bbox))
    point_candidates= data_all_PhasePoints.loc[point_candidate_idx]
    # get the precise points in the buffer polygon query
    final_selection_buffer= point_candidates.loc[point_candidates.within(buffer_polygon)]
    # count the unique minerals from the final selection
    minerals_buffer= final_selection_buffer.groupby('Mineral')['Mineral'].count()
    # calculate their amount in perecentage
    minerals_buffer_perc= (100/sum(minerals_buffer))*minerals_buffer
    # store following information into the DataFrame:  
    # 'mineral'(=index) 'mineral_amount%' 'grainID' 'ConcAge' (=optional)
    # mieral amount in %
    ResultDataFrame= minerals_buffer_perc.rename('mineral_amount_perc').to_frame()
    # measured zircon grain ID
    ResultDataFrame['grainID']= buffer['SampleID_GrainID'].iloc[i]
    # optional: Get the Concordia age of the zircon surrounded by the buffer, 
    # which was stored in the buffer's geodatabase from ArcGis
    ResultDataFrame['ConcAge']= buffer['GrainID_concAge'].iloc[i]
    # store the DataFrame in the empty DataFrame, which was created before the iteration
    Table_buffer= Table_buffer.append(ResultDataFrame)
    # empty the ResultDataFrame to store the data from the next iteration step
    ResultDataFrame= []
    # empty the point_candidate_idx list for the next iteration step
    point_candidate_idx=[]
 
 #------------------------------------------------------------------------------  
 ## OUTPUT
    
# save the result table
Table_buffer.to_csv(r'C:\foldername\filename.csv')
    

